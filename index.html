<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Technical Documentation by Cristian Cáceres</title>
    <link rel="stylesheet" href="styles.css">
</head>

<body id="box">
    <nav id="navbar">
        <img src=logoPython.png>
        <header>PYTHON DOCUMENTATION</header>
        <a class="nav-link" href="#Introduction"><b>Introduction</b></a>
        <a class="nav-link" href="#Lexical_analysis"><b>Lexical analysis</b></a>
        <a class="nav-link" href="#Control_Flow_Tools"><b>Control Flow Tools</b></a>
        <a class="nav-link" href="#Data_Structures"><b>Data Structures</b></a>
        <a class="nav-link" href="#Modules"><b>Modules</b></a>
        <a class="nav-link" href="#Input_and_Output"><b>Input and Output</b></a>
        <a class="nav-link" href="#Errors_and_Exceptions"><b>Errors and Exceptions</b></a>
        <a class="nav-link" href="#Reference"><b>Reference</b></a>
    </nav>
    <!-- User Story #1: I can see a main element with a corresponding id="main-doc", which contains the page's main content 
        (technical documentation). -->
    <main id="main-doc">
        <!-- User Story #2: Within the #main-doc element, I can see several section elements, each with a class of main-section. There should be a minimum of 5. -->
        <section class="main-section" id="PYTHON_DOCUMENTATION">
            <header>PYTHON DOCUMENTATION</header>
        </section>
        <section class="main-section" id="Introduction">
            <header><b>Introduction</b></header>
            <article>
                <p>&nbsp&nbsp&nbsp Python is a high level general-purpose programming language. It uses a multi-paradigm approach, meaning it supports procedural, object-oriented, and some functional programming constructs.</p>
                <p>&nbsp&nbsp&nbsp It was created by Guido van Rossum as a successor to another language (called ABC) between 1985 and 1990, and is currently used on a large array of domains like web development, desktop applications, data science, DevOps,
                    and automation/productivity.
                </p>
                <p>&nbsp&nbsp&nbspPython is an easy to learn, powerful programming language. It has efficient high-level data structures and a simple but effective approach to object-oriented programming. Python’s elegant syntax and dynamic typing, together
                    with its interpreted nature, make it an ideal language for scripting and rapid application development in many areas on most platforms.
                </p>
                <p>&nbsp&nbsp&nbspThe Python interpreter and the extensive standard library are freely available in source or binary form for all major platforms from the Python Web site, https://www.python.org/, and may be freely distributed. The same site
                    also contains distributions of and pointers to many free third party Python modules, programs and tools, and additional documentation.</p>
                <p>&nbsp&nbsp&nbspThe Python interpreter is easily extended with new functions and data types implemented in C or C++ (or other languages callable from C). Python is also suitable as an extension language for customizable applications.</p>
                <br>
            </article>
        </section>
        <section class="main-section" id="Lexical_analysis">
            <header><b>Lexical analysis</b></header>
            <article>
                <p>&nbsp&nbsp&nbspA Python program is read by a parser. Input to the parser is a stream of tokens, generated by the lexical analyzer. This chapter describes how the lexical analyzer breaks a file into tokens.</p>
                <p>&nbsp&nbsp&nbspPython reads program text as Unicode code points; the encoding of a source file can be given by an encoding declaration and defaults to UTF-8, see PEP 3120 for details. If the source file cannot be decoded, a SyntaxError
                    is raised.</p>
                &nbsp&nbsp&nbsp
                <li>Line structure</li>
                <p>&nbsp&nbsp&nbspA Python program is divided into a number of logical lines.</p>
                &nbsp&nbsp&nbsp
                <li>Logical lines</li>
                <p>&nbsp&nbsp&nbspThe end of a logical line is represented by the token NEWLINE. Statements cannot cross logical line boundaries except where NEWLINE is allowed by the syntax (e.g., between statements in compound statements). A logical line
                    is constructed from one or more physical lines by following the explicit or implicit line joining rules.</p>
                &nbsp&nbsp&nbsp
                <li>Physical lines</li>
                <p>&nbsp&nbsp&nbspA physical line is a sequence of characters terminated by an end-of-line sequence. In source files and strings, any of the standard platform line termination sequences can be used - the Unix form using ASCII LF (linefeed),
                    the Windows form using the ASCII sequence CR LF (return followed by linefeed), or the old Macintosh form using the ASCII CR (return) character. All of these forms can be used equally, regardless of platform. The end of input also serves
                    as an implicit terminator for the final physical line. When embedding Python, source code strings should be passed to Python APIs using the standard C conventions for newline characters (the \n character, representing ASCII LF, is
                    the line terminator).
                </p>
                <br>
            </article>
        </section>
        <section class="main-section" id="Control_Flow_Tools">
            <header><b>Control Flow Tools</b></header>
            <article>
                <p>&nbsp&nbsp&nbspBesides the while statement just introduced, Python uses the usual flow control statements known from other languages, with some twists.</p>
                &nbsp&nbsp&nbsp
                <li>if Statements</li>
                <p>&nbsp&nbsp&nbspPerhaps the most well-known statement type is the if statement. For example:</p>
                <code> x = int(input("Please enter an integer: "))<br>
                    Please enter an integer: 42<br>
                    &gt;&gt;&gt; if x &lt; 0:<br>
                    ...     x = 0<br>
                    ...     print('Negative changed to zero')<br>
                    ... elif x == 0:<br>
                    ...     print('Zero')<br>
                    ... elif x == 1:<br>
                    ...     print('Single')<br>
                    ... else:<br>
                    ...     print('More')<br>
                    ...<br>
                    More<br>
                    </code>&gt;&gt;&gt;
                <p>&nbsp&nbsp&nbspThere can be zero or more elif parts, and the else part is optional. The keyword ‘elif’ is short for ‘else if’, and is useful to avoid excessive indentation. An if … elif … elif … sequence is a substitute for the switch
                    or case statements found in other languages.</p>
                <br> &nbsp&nbsp&nbsp
                <li>for Statements</li>
                <p>&nbsp&nbsp&nbspThe for statement in Python differs a bit from what you may be used to in C or Pascal. Rather than always iterating over an arithmetic progression of numbers (like in Pascal), or giving the user the ability to define both
                    the iteration step and halting condition (as C), Python’s for statement iterates over the items of any sequence (a list or a string), in the order that they appear in the sequence. For example (no pun intended):</p>
                <code> # Measure some strings:<br>
    ... words = ['cat', 'window', 'defenestrate']<br>
    &gt;&gt;&gt; for w in words:<br>
    ...     print(w, len(w))<br>
    ...<br>
    cat 3<br>
    window 6<br>
    defenestrate 12<br>
    </code>&gt;&gt;&gt;
                <p>&nbsp&nbsp&nbspCode that modifies a collection while iterating over that same collection can be tricky to get right. Instead, it is usually more straight-forward to loop over a copy of the collection or to create a new collection:</p>
                <code>
    # Strategy:  Iterate over a copy<br>
for user, status in users.copy().items():<br>
    if status == 'inactive':<br>
        del users[user]<br>
# Strategy:  Create a new collection<br>
active_users = {}<br>
for user, status in users.items():<br>
    if status == 'active':<br>
        active_users[user] = status<br>
</code>
                <br> &nbsp&nbsp&nbsp
                <li>The range() Function</li>
                <br>
                <p>&nbsp&nbsp&nbspIf you do need to iterate over a sequence of numbers, the built-in function range() comes in handy. It generates arithmetic progressions:</p>
                <code>&gt;&gt;&gt; for i in range(5):<br>
                0<br>
                1<br>
                2<br>
                3<br>
                4<br>
                </code>
                <p>&nbsp&nbsp&nbspThe given end point is never part of the generated sequence; range(10) generates 10 values, the legal indices for items of a sequence of length 10. It is possible to let the range start at another number, or to specify a
                    different increment (even negative; sometimes this is called the ‘step’):</p>
                <code>&gt;&gt;&gt; list(range(5, 10))<br>
                [5, 6, 7, 8, 9]<br>
                <br>
                &gt;&gt;&gt; list(range(0, 10, 3))<br>
                [0, 3, 6, 9]<br>
                <br>
                &gt;&gt;&gt; list(range(-10, -100, -30))<br>
                [-10, -40, -70]<br>
                 </code>
                <p>&nbsp&nbsp&nbspTo iterate over the indices of a sequence, you can combine range() and len() as follows:</p>
                <code>&gt;&gt;&gt; a = ['Mary', 'had', 'a', 'little', 'lamb']<br>
                    &gt;&gt;&gt; for i in range(len(a)):<br>
                    ...     print(i, a[i])<br>
                    ...<br>
                    0 Mary<br>
                    1 had<br>
                    2 a<br>
                    3 little<br>
                    4 lamb<br>
                    </code>
            </article>
            <br>
        </section>

        <section class="main-section" id="Data_Structures">
            <header><b>Data Structures</b></header>
            <article>
                <br>
                <p>&nbsp&nbsp&nbspThis chapter describes some things you’ve learned about already in more detail, and adds some new things as well.</p>
                <code></code>
                <p>&nbsp&nbsp&nbspMore on Lists<br>The list data type has some more methods. Here are all of the methods of list objects:</p>
                <br> &nbsp&nbsp&nbsp
                <li>list.append(x)</li>
                <p>&nbsp&nbsp&nbspAdd an item to the end of the list. Equivalent to a[len(a):] = [x]. </p>
                <br> &nbsp&nbsp&nbsp
                <li>list.extend(iterable)</li>
                <p>&nbsp&nbsp&nbsp Extend the list by appending all the items from the iterable. Equivalent to a[len(a):] = iterable</p>
                <br> &nbsp&nbsp&nbsp
                <li>list.insert(i, x)</li>
                <p>&nbsp&nbsp&nbsp Insert an item at a given position. The first argument is the index of the element before which to insert, so a.insert(0, x) inserts at the front of the list, and a.insert(len(a), x) is equivalent to a.append(x).</p>
                <br> &nbsp&nbsp&nbsp
                <li>list.remove(x)</li>
                <p>&nbsp&nbsp&nbspRemove the first item from the list whose value is equal to x. It raises a ValueError if there is no such item. </p>
                <br> &nbsp&nbsp&nbsp
                <li>list.pop([i])</li>
                <p>&nbsp&nbsp&nbsp Remove the item at the given position in the list, and return it. If no index is specified, a.pop() removes and returns the last item in the list. (The square brackets around the i in the method signature denote that the
                    parameter is optional, not that you should type square brackets at that position. You will see this notation frequently in the Python Library Reference.)</p>
                <br> &nbsp&nbsp&nbsp
                <li>list.clear()</li>
                <p>&nbsp&nbsp&nbspRemove all items from the list. Equivalent to del a[:]. </p>
                <br> &nbsp&nbsp&nbsp
                <li>list.index(x[, start[, end]])</li>
                <p>&nbsp&nbsp&nbsp Return zero-based index in the list of the first item whose value is equal to x. Raises a ValueError if there is no such item. The optional arguments start and end are interpreted as in the slice notation and are used to
                    limit the search to a particular subsequence of the list. The returned index is computed relative to the beginning of the full sequence rather than the start argument.
                </p>
                <br> &nbsp&nbsp&nbsp
                <li>list.count(x)</li>
                <p>&nbsp&nbsp&nbsp Return the number of times x appears in the list.</p>
                <br> &nbsp&nbsp&nbsp
                <li>list.sort(*, key=None, reverse=False)</li>
                <p>&nbsp&nbsp&nbsp Sort the items of the list in place (the arguments can be used for sort customization, see sorted() for their explanation).</p>
                <br> &nbsp&nbsp&nbsp
                <li>list.reverse()</li>
                <p>&nbsp&nbsp&nbsp Reverse the elements of the list in place</p>
                <br> &nbsp&nbsp&nbsp
                <li>list.copy()</li>
                <p>&nbsp&nbsp&nbsp Return a shallow copy of the list. Equivalent to a[:].</p>
                <br>
                <p>&nbsp&nbsp&nbspAn example that uses most of the list methods:</p>
                <code>&gt;&gt;&gt; fruits = ['orange', 'apple', 'pear', 'banana', 'kiwi', 'apple', 'banana'] <br>
                    &gt;&gt;&gt; fruits.count('apple') <br>
                    2 <br>
                    &gt;&gt;&gt; fruits.count('tangerine') <br>
                    0 <br>
                    &gt;&gt;&gt; fruits.index('banana') <br>
                    3 <br>
                    &gt;&gt;&gt; fruits.index('banana', 4)  # Find next banana starting a position 4 <br>
                    6 <br>
                    &gt;&gt;&gt; fruits.reverse() <br>
                    &gt;&gt;&gt; fruits <br>
                    ['banana', 'apple', 'kiwi', 'banana', 'pear', 'apple', 'orange'] <br>
                    &gt;&gt;&gt; fruits.append('grape') <br>
                    &gt;&gt;&gt; fruits <br>
                    ['banana', 'apple', 'kiwi', 'banana', 'pear', 'apple', 'orange', 'grape'] <br>
                    &gt;&gt;&gt; fruits.sort() <br>
                    &gt;&gt;&gt; fruits <br>
                    ['apple', 'apple', 'banana', 'banana', 'grape', 'kiwi', 'orange', 'pear'] <br>
                    &gt;&gt;&gt; fruits.pop() <br>
                    ...<br>
                    'pear'<br>
                    </code>
                <p>&nbsp&nbsp&nbspYou might have noticed that methods like insert, remove or sort that only modify the list have no return value printed – they return the default None. 1 This is a design principle for all mutable data structures in Python.
                    Another thing you might notice is that not all data can be sorted or compared. For instance, [None, 'hello', 10] doesn’t sort because integers can’t be compared to strings and None can’t be compared to other types. Also, there are
                    some types that don’t have a defined ordering relation. For example, 3+4j &lt; 5+7j isn’t a valid comparison </p>
            </article>
            <br>
        </section>

        <section class="main-section" id="Modules">
            <header><b>Modules</b></header>
            <article>
                <p>&nbsp&nbsp&nbspIf you quit from the Python interpreter and enter it again, the definitions you have made (functions and variables) are lost. Therefore, if you want to write a somewhat longer program, you are better off using a text editor
                    to prepare the input for the interpreter and running it with that file as input instead. This is known as creating a script. As your program gets longer, you may want to split it into several files for easier maintenance. You may also
                    want to use a handy function that you’ve written in several programs without copying its definition into each program. To support this, Python has a way to put definitions in a file and use them in a script or in an interactive instance
                    of the interpreter. Such a file is called a module; definitions from a module can be imported into other modules or into the main module (the collection of variables that you have access to in a script executed at the top level and
                    in calculator mode). A module is a file containing Python definitions and statements. The file name is the module name with the suffix .py appended. Within a module, the module’s name (as a string) is available as the value of the
                    global variable __name__. For instance, use your favorite text editor to create a file called fibo.py in the current directory with the following contents:
                </p>
                <code># Fibonacci numbers module<br>
                    <br>
                    def fib(n):    # write Fibonacci series up to n<br>
                        a, b = 0, 1<br>
                        while a &lt; n:
                    </code>
                <br>
                <code>        print(a, end=' ')<br>
                    a, b = b, a+b<br>
                print()<br>
            
            def fib2(n):   # return Fibonacci series up to n<br>
                result = []<br>
                a, b = 0, 1<br>
                while a &lt; n:<br>
                    result.append(a)<br>
                    a, b = b, a+b<br>
                return result
            </code>
                <br>
                <p>&nbsp&nbsp&nbspNow enter the Python interpreter and import this module with the following command:</p>
                <code>&gt;&gt;&gt; import fibo</code>
                <p>&nbsp&nbsp&nbspThis does not enter the names of the functions defined in fibo directly in the current symbol table; it only enters the module name fibo there. Using the module name you can access the functions:</p>

                <code>&gt;&gt;&gt; fibo.fib(1000)  <br>
                0 1 1 2 3 5 8 13 21 34 55 89 144 233 377 610 987  <br>
                &gt;&gt;&gt; fibo.fib2(100)  <br>
                 [0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89]  <br>
                 &gt;&gt;&gt; fibo.__name__  <br>
                'fibo'  
            </code>
                <br>
                <p>&nbsp&nbsp&nbspIf you intend to use a function often you can assign it to a local name:</p>
                <code>&gt;&gt;&gt; fib = fibo.fib  <br>
    &gt;&gt;&gt; fib(500)  <br>
    0 1 1 2 3 5 8 13 21 34 55 89 144 233 377 
    </code>
                <br>
            </article>
        </section>
        <section class="main-section" id="Input_and_Output">
            <header><b>Input and Output</b></header>
            <article>
                <p>&nbsp&nbsp&nbspThere are several ways to present the output of a program; data can be printed in a human-readable form, or written to a file for future use. This chapter will discuss some of the possibilities.</p>
                &nbsp&nbsp&nbsp
                <li>Fancier Output Formatting</li>
                <p>&nbsp&nbsp&nbspSo far we’ve encountered two ways of writing values: expression statements and the print() function. (A third way is using the write() method of file objects; the standard output file can be referenced as sys.stdout. See
                    the Library Reference for more information on this.) Often you’ll want more control over the formatting of your output than simply printing space-separated values. There are several ways to format output.
                </p>
                &nbsp&nbsp&nbsp
                <li>To use formatted string literals, begin a string with f or F before the opening quotation mark or triple quotation mark. Inside this string, you can write a Python expression between { and } characters that can refer to variables or literal
                    values.
                </li>
                <code&gt;&gt;&gt;> year = 2016<br> &gt;&gt;&gt; event = 'Referendum'<br> &gt;&gt;&gt; f'Results of the {year} {event}'<br> 'Results of the 2016 Referendum'<br>
                    </code>&gt;&gt;&gt; &nbsp&nbsp&nbsp
                    <li>The str.format() method of strings requires more manual effort. You’ll still use { and } to mark where a variable will be substituted and can provide detailed formatting directives, but you’ll also need to provide the information to
                        be formatted.
                    </li>
                    <code>&gt;&gt;&gt; yes_votes = 42_572_654<br>
                    &gt;&gt;&gt; no_votes = 43_132_495<br>
                    &gt;&gt;&gt; percentage = yes_votes / (yes_votes + no_votes)<br>
                    &gt;&gt;&gt; '{:-9} YES votes  {:2.2%}'.format(yes_votes, percentage)<br>
                    ' 42572654 YES votes  49.67%'<br>
                    </code><br> &nbsp&nbsp&nbsp
                    <li>Finally, you can do all the string handling yourself by using string slicing and concatenation operations to create any layout you can imagine. The string type has some methods that perform useful operations for padding strings to
                        a given column width.</li>
                    <br>
                    <p>&nbsp&nbsp&nbspWhen you don’t need fancy output but just want a quick display of some variables for debugging purposes, you can convert any value to a string with the repr() or str() functions. The str() function is meant to return
                        representations of values which are fairly human-readable, while repr() is meant to generate representations which can be read by the interpreter (or will force a SyntaxError if there is no equivalent syntax). For objects which
                        don’t have a particular representation for human consumption, str() will return the same value as repr(). Many values, such as numbers or structures like lists and dictionaries, have the same representation using either function.
                        Strings, in particular, have two distinct representations.
                        <br> Some examples:
                    </p>
                    <code>&gt;&gt;&gt; s = 'Hello, world.'<br>
                    &gt;&gt;&gt; str(s)<br>
                    'Hello, world.'<br>
                    &gt;&gt;&gt; repr(s)<br>
                    "'Hello, world.'"<br>
                    &gt;&gt;&gt; str(1/7)<br>
                    '0.14285714285714285'<br>
                    &gt;&gt;&gt; x = 10 * 3.25<br>
                    &gt;&gt;&gt; y = 200 * 200<br>
                    &gt;&gt;&gt; s = 'The value of x is ' + repr(x) + ', and y is ' + repr(y) + '...'<br>
                    &gt;&gt;&gt; print(s)<br>
                    The value of x is 32.5, and y is 40000...<br>
                    &gt;&gt;&gt; # The repr() of a string adds string quotes and backslashes:<br>
                    ... hello = 'hello, world\n'<br>
                    &gt;&gt;&gt; hellos = repr(hello)<br>
                    &gt;&gt;&gt; print(hellos)<br>
                    'hello, world\n'<br>
                    &gt;&gt;&gt; # The argument to repr() may be any Python object:<br>
                    ... repr((x, y, ('spam', 'eggs')))<br>
                    "(32.5, 40000, ('spam', 'eggs'))"<br>
                    </code>
                    <br> &nbsp&nbsp&nbsp
                    <li>Reading and Writing Files</li>
                    <p>&nbsp&nbsp&nbspopen() returns a file object, and is most commonly used with two arguments: open(filename, mode).</p>
                    <code>&gt;&gt;&gt; f = open('workfile', 'w')></code>
                    <br>
                    <p>&nbsp&nbsp&nbspThe first argument is a string containing the filename. The second argument is another string containing a few characters describing the way in which the file will be used. mode can be 'r' when the file will only be
                        read, 'w' for only writing (an existing file with the same name will be erased), and 'a' opens the file for appending; any data written to the file is automatically added to the end. 'r+' opens the file for both reading and writing.
                        The mode argument is optional; 'r' will be assumed if it’s omitted.
                    </p>
                    <p>&nbsp&nbsp&nbspNormally, files are opened in text mode, that means, you read and write strings from and to the file, which are encoded in a specific encoding. If encoding is not specified, the default is platform dependent (see open()).
                        'b' appended to the mode opens the file in binary mode: now the data is read and written in the form of bytes objects. This mode should be used for all files that don’t contain text.
                    </p>
                    <p>&nbsp&nbsp&nbsp In text mode, the default when reading is to convert platform-specific line endings (\n on Unix, \r\n on Windows) to just \n. When writing in text mode, the default is to convert occurrences of \n back to platform-specific
                        line endings. This behind-the-scenes modification to file data is fine for text files, but will corrupt binary data like that in JPEG or EXE files. Be very careful to use binary mode when reading and writing such files.
                    </p>
                    <p>&nbsp&nbsp&nbspIt is good practice to use the with keyword when dealing with file objects. The advantage is that the file is properly closed after its suite finishes, even if an exception is raised at some point. Using with is also
                        much shorter than writing equivalent try-finally blocks:
                    </p>

                    <code>&gt;&gt;&gt; with open('workfile') as f: <br>
                    ...     read_data = f.read() <br>
                    
                    &gt;&gt;&gt; # We can check that the file has been automatically closed. <br>
                    &gt;&gt;&gt; f.closed <br>
                    True 
                    </code>
                    <br>
                    <p>&nbsp&nbsp&nbspIf you’re not using the with keyword, then you should call f.close() to close the file and immediately free up any system resources used by it.</p>
                    <code>Warning <br>Calling f.write() without using the with keyword or calling f.close() might result in the arguments of f.write() not being completely written to the disk, even if the program exits successfully.</code>
                    <br>
                    <p>&nbsp&nbsp&nbspAfter a file object is closed, either by a with statement or by calling f.close(), attempts to use the file object will automatically fail.</p>
                    <code> f.close()<br>
                    &gt;&gt;&gt; f.read()<br>
                    Traceback (most recent call last):<br>
                      File "&lt;stdin&gt;", line 1, in &lt;module&gt;<br>
                    ValueError: I/O operation on closed file.
                    </code>&gt;&gt;&gt;
                    <br>

        </section>
        <section class="main-section" id="Errors_and_Exceptions">
            <header><b>Errors and Exceptions</b></header>
            <article>
                <p>&nbsp&nbsp&nbspUntil now error messages haven’t been more than mentioned, but if you have tried out the examples you have probably seen some. There are (at least) two distinguishable kinds of errors: syntax errors and exceptions.</p>
                &nbsp&nbsp&nbsp
                <li>Syntax Errors</li>
                <p>&nbsp&nbsp&nbspSyntax errors, also known as parsing errors, are perhaps the most common kind of complaint you get while you are still learning Python:/p>
                    <code>&gt;&gt;&gt; while True print('Hello world')<br>
                    File "&lt;stdin&gt;", line 1<br>
                      while True print('Hello world')<br>
                                     ^<br>
                  SyntaxError: invalid syntax<br>
                  </code><br>
                    <p>&nbsp&nbsp&nbspThe parser repeats the offending line and displays a little ‘arrow’ pointing at the earliest point in the line where the error was detected. The error is caused by (or at least detected at) the token preceding the arrow:
                        in the example, the error is detected at the function print(), since a colon (':') is missing before it. File name and line number are printed so you know where to look in case the input came from a script.</p>
                    <br> &nbsp&nbsp&nbsp
                    <li>Exceptions</li>
                    <p>&nbsp&nbsp&nbspEven if a statement or expression is syntactically correct, it may cause an error when an attempt is made to execute it. Errors detected during execution are called exceptions and are not unconditionally fatal: you will
                        soon learn how to handle them in Python programs. Most exceptions are not handled by programs, however, and result in error messages as shown here:</p>
                    <code>&gt;&gt;&gt; 10 * (1/0)<br>
                    Traceback (most recent call last):<br>
                      File "&lt;stdin&gt;", line 1, in &lt;module&gt;<br>
                    ZeroDivisionError: division by zero<br>
                    &gt;&gt;&gt; 4 + spam*3<br>
                    Traceback (most recent call last):<br>
                      File "&lt;stdin&gt;", line 1, in &lt;module&gt;<br>
                    NameError: name 'spam' is not defined<br>
                    &gt;&gt;&gt; '2' + 2<br>
                    Traceback (most recent call last):<br>
                      File "&lt;stdin&gt;", line 1, in &lt;module&gt;<br>
                    TypeError: can only concatenate str (not "int") to str<br>
                    </code>
                    <br>
                    <p>&nbsp&nbsp&nbspThe last line of the error message indicates what happened. Exceptions come in different types, and the type is printed as part of the message: the types in the example are ZeroDivisionError, NameError and TypeError.
                        The string printed as the exception type is the name of the built-in exception that occurred. This is true for all built-in exceptions, but need not be true for user-defined exceptions (although it is a useful convention). Standard
                        exception names are built-in identifiers (not reserved keywords).</p>
                    <p>&nbsp&nbsp&nbspThe rest of the line provides detail based on the type of exception and what caused it.</p>
                    <p>&nbsp&nbsp&nbspThe preceding part of the error message shows the context where the exception occurred, in the form of a stack traceback. In general it contains a stack traceback listing source lines; however, it will not display lines
                        read from standard input.
                    </p>
                    <p>&nbsp&nbsp&nbspBuilt-in Exceptions lists the built-in exceptions and their meanings.</p>
                    &nbsp&nbsp&nbsp
                    <li>Handling Exceptions</li>
                    <p>&nbsp&nbsp&nbspIt is possible to write programs that handle selected exceptions. Look at the following example, which asks the user for input until a valid integer has been entered, but allows the user to interrupt the program (using
                        Control-C or whatever the operating system supports); note that a user-generated interruption is signalled by raising the KeyboardInterrupt exception.</p>
                    <code> while True:<br>
                    ...     try:<br>
                    ...         x = int(input("Please enter a number: "))
                    </code>
                    <br>
                    <code>...         break<br>
                    ...     except ValueError:<br>
                    ...         print("Oops!  That was no valid number.  Try again...")
                    </code>
                    <br>
                    <p>&nbsp&nbsp&nbspThe try statement works as follows. • First, the try clause (the statement(s) between the try and except keywords) is executed. • If no exception occurs, the except clause is skipped and execution of the try statement
                        is finished. • If an exception occurs during execution of the try clause, the rest of the clause is skipped. Then if its type matches the exception named after the except keyword, the except clause is executed, and then execution
                        continues after the try statement. • If an exception occurs which does not match the exception named in the except clause, it is passed on to outer try statements; if no handler is found, it is an unhandled exception and execution
                        stops with a message as shown above.

                    </p>
                    <p>&nbsp&nbsp&nbspA try statement may have more than one except clause, to specify handlers for different exceptions. At most one handler will be executed. Handlers only handle exceptions that occur in the corresponding try clause, not
                        in other handlers of the same try statement. An except clause may name multiple exceptions as a parenthesized tuple, for example:</p>
                    <code>... except (RuntimeError, TypeError, NameError): <br>
                     ...     pass<br>
                    </code>
                    <br>
                    <p>&nbsp&nbsp&nbspA class in an except clause is compatible with an exception if it is the same class or a base class thereof (but not the other way around — an except clause listing a derived class is not compatible with a base class).
                        For example, the following code will print B, C, D in that order:</p>

                    <br>
                    <code>class B(Exception):<br>
                        pass<br>
                        <br>
                    class C(B):<br>
                        pass<br>
                        <br>
                    class D(C):<br>
                        pass<br>
                        <br>
                    for cls in [B, C, D]:<br>
                        try:<br>
                            raise cls()<br>
                        except D:<br>
                            print("D")<br>
                        except C:<br>
                            print("C")<br>
                        except B:<br>
                            print("B")
                    </code><br>
                    <p>&nbsp&nbsp&nbspNote that if the except clauses were reversed (with except B first), it would have printed B, B, B — the first matching except clause is triggered.</p>
                    <p>&nbsp&nbsp&nbspThe last except clause may omit the exception name(s), to serve as a wildcard. Use this with extreme caution, since it is easy to mask a real programming error in this way! It can also be used to print an error message
                        and then re-raise the exception (allowing a caller to handle the exception as well):</p>
                    <code>import sys<br>
                        <br>
                        try:<br>
                            f = open('myfile.txt')<br>
                            s = f.readline()<br>
                            i = int(s.strip())<br>
                        except OSError as err:<br>
                            print("OS error: {0}".format(err))<br>
                        except ValueError:<br>
                            print("Could not convert data to an integer.")<br>
                        except:<br>
                            print("Unexpected error:", sys.exc_info()[0])<br>
                            raise
                        </code><br>
                    <p>&nbsp&nbsp&nbspThe try … except statement has an optional else clause, which, when present, must follow all except clauses. It is useful for code that must be executed if the try clause does not raise an exception. For example:</p>
                    <code>for arg in sys.argv[1:]:<br>
                        try:<br>
                            f = open(arg, 'r')<br>
                        except OSError:<br>
                            print('cannot open', arg)<br>
                        else:<br>
                            print(arg, 'has', len(f.readlines()), 'lines')<br>
                            f.close()<br>
                    </code>
                    <br>
                    <p>&nbsp&nbsp&nbspThe use of the else clause is better than adding additional code to the try clause because it avoids accidentally catching an exception that wasn’t raised by the code being protected by the try … except statement.</p>
                    <p>&nbsp&nbsp&nbspWhen an exception occurs, it may have an associated value, also known as the exception’s argument. The presence and type of the argument depend on the exception type.</p>
                    <p>&nbsp&nbsp&nbspThe except clause may specify a variable after the exception name. The variable is bound to an exception instance with the arguments stored in instance.args. For convenience, the exception instance defines __str__()
                        so the arguments can be printed directly without having to reference .args. One may also instantiate an exception first before raising it and add any attributes to it as desired.</p>
                    <code>&gt;&gt;&gt; try:<br>
                        ...     raise Exception('spam', 'eggs')<br>
                        ... except Exception as inst:<br>
                        ...     print(type(inst))    # the exception instance<br>
                        ...     print(inst.args)     # arguments stored in .args<br>
                        ...     print(inst)          # __str__ allows args to be printed directly,<br>
                        ...                          # but may be overridden in exception subclasses<br>
                        ...     x, y = inst.args     # unpack args<br>
                        ...     print('x =', x)<br>
                        ...     print('y =', y)<br>
                        ... &lt;class "Exception"&gt; <br>
                         ('spam','eggs') <br>
                    ('spam','eggs')
                    <br> x = spam<br> y = eggs
                    </code>
                    <br>
                    <p>&nbsp&nbsp&nbspIf an exception has arguments, they are printed as the last part (‘detail’) of the message for unhandled exceptions.</p>
                    <p>&nbsp&nbsp&nbspException handlers don’t just handle exceptions if they occur immediately in the try clause, but also if they occur inside functions that are called (even indirectly) in the try clause. For example:</p>
                    <code> def this_fails():<br>
                        ...     x = 1/0<br>
                        ...<br>
                        &gt;&gt;&gt; try:<br>
                        ...     this_fails()<br>
                        ... except ZeroDivisionError as err:<br>
                        ...     print('Handling run-time error:', err)<br>
                        ...<br>
                        Handling run-time error: division by zero
                        </code>&gt;&gt;&gt;
                    <br>
            </article>
        </section>
        <section class="main-section" id="Reference">
            <header>Reference</header>
            <article>For a complete reference All the documentation in this page is taken from
                <a href="https://docs.python.org/3/tutorial/index.html">Python.org</a>
            </article>
            <br>
            <p id="foot"><strong>© Cristian V. Cáceres L. 2021&nbsp;</strong></p>
        </section>


    </main>

</body>

</html>
